# ovs-tracing

<div dir="rtl">

![image](https://github.com/matinborhani/ovs-tracing/blob/main/screenshots/arch.JPG?raw=true)

 |
| --- |
| سید حمیدرضا میریگانه
متین برهانی  |
| زمستان1402 |

# قسمت اول: کلیات OVS

## توضیح مختصر در مورد OVS:

Open vSwitch یا به اختصار OVS، یک پیاده‌سازی منبع باز از یک سوئیچ چند لایه مجازی توزیع شده است. [هدف اصلی](https://en.wikipedia.org/wiki/Open_vSwitch)Open vSwitch ارائه یک پشته سوئیچ برای محیط‌های مجازی‌سازی سخت‌افزاری است، در حالی که از چندین پروتکل و استاندارد مورد استفاده در شبکه‌های کامپیوتری پشتیبانی می‌کند.

## نقاط قوت OVS:

1. پشتیبانی از استانداردها: OVS از چندین پروتکل و استاندارد مورد استفاده در شبکه‌های کامپیوتری پشتیبانی می‌کند.
2. قابلیت اتوماسیون شبکه: OVS قابلیت اتوماسیون شبکه را از طریق افزونه‌های برنامه‌نویسی فراهم می‌کند.
3. پشتیبانی از توزیع شفاف: OVS طوری طراحی شده است که پشتیبانی از توزیع شفاف در سرورهای فیزیکی متعدد را فراهم می‌کند.

## نقاط ضعف OVS:

1. پیچیدگی در پیکربندی
2.  نیاز به دانش فنی خاص برای استفاده بهینه

## پیاده سازی OVS:

در این قسمت به صورت مختصر، اقداماتی که در راستای ایجاد Switch مجازی شبکه انجام شد، شرح داده می‌شود.

1. در ابتدا با استفاده از یک ماشین مجازی لینوکسی، اقدام به ایجاد دو Name Space به نام های VRF1 و VRF2 کردیم.
2. سپس اقدام به ایجاد چهار Interface شبکه به نام های veth1 و veth2 و veth3 و veth4 کردیم.
3. سپس Interface با نام veth1 را به Namespace VRF1 و veth3 را به Namespace VRF3 اختصاص دادیم.
4. سپس به هر Interface یک IP منحصر به فرد در محدوده 10.10.10.255 اختصاص داده شد.

![](RackMultipart20240109-1-uw5vs1_html_649a162bab100cca.png)

تصویر 1: Interface های Namespace به نامVRF1

![](RackMultipart20240109-1-uw5vs1_html_b2973db2e0d0fad7.png)

تصویر 2: ‏: ‏Interface‏ های ‏Namespace‏ به نامVRF2

1. در ادامه با ایجاد یک Virtual Switch و ساخت Bridge بر روی آن، اقدام به برقراری ارتباط بین دو Namespace کردیم.

![](RackMultipart20240109-1-uw5vs1_html_4c3668744a22ea5e.png)

تصویر 3: مشاهده اطلاعات Switch مجازی تعریف شده

1. برای مثال بین Namespace با نام VRF1 یک بسته ICMP به Namespace با نام VRF2 ارسال کردیم.

![](RackMultipart20240109-1-uw5vs1_html_a15e3da698af593a.jpg)

تصویر 4: ارسال بسته با استفاده از Namespace با نام VRF1 به VRF2 با آدرس 10.10.10.2

![](RackMultipart20240109-1-uw5vs1_html_30b06e1bc3db8a0e.jpg)

تصویر 5: نگاه کلی به دستورات ساختن Name Space و Interface های مربوطه و برقراری ارتباط بین آن‌ها

![](RackMultipart20240109-1-uw5vs1_html_5e2fef114ec7c474.jpg)

تصویر6: Interface های ساخته شده

## معماری Namespace و OVS:

![](RackMultipart20240109-1-uw5vs1_html_d6b417391def9311.png)

تصویر 7: معماری OVS

# قسمت دوم: سناریوی Ping

## مقدمات سناریو Ping:

در ابتدا با استفاده از Name Space های ساخته شده در قسمت قبل، اقدام به ping کردن VRF1 و VRF2 کردیم. که در شکل زیر مشهود است:

![](RackMultipart20240109-1-uw5vs1_html_ba58330bb234ce40.png)

تصویر 8: ارسال دستور ICMP از طریق VRF1 به VRF2

## برای آشنایی با Function هایی که در زمان اجرای دستور ping صدا زده می شوند:

برای پی بردن به Function های مهم ovs در ابتدا یک بار دستور perf را به صورت عادی اجرا کرده و بار دیگر دستور perf را حین سناریو ping اجرا کردیم. در ادامه عکس های زیر که بخشی از نتایج بدست آمده است، نشان داده می‌شود.

![](RackMultipart20240109-1-uw5vs1_html_316118507106cc44.png)

تصویر 9: پاره ای از توابع که در حین سناریو Ping صدا زده می شوند

![](RackMultipart20240109-1-uw5vs1_html_1cb75d2f7b92002b.png)

تصویر 10: پاره ای از توابع که بدون سناریو Ping صدا زده می شوند

در نهایت با مقایسه نتایج این دو عملیات، توابعی که تنها در حین سناریو Ping صدا زده می شوند، یافت شد. (توابع بر اساس Hit مرتب شده اند):

![](RackMultipart20240109-1-uw5vs1_html_c2f64bd155c8218c.png)

تصویر 11: توابع مختص سناریو Ping

با توجه به نتایج بدست آمده در ادامه تمرکز خود را بر روی 13 رخدادی که در شکل مشخص شده و بیشترین تعداد فراخوانی را داشته اند، منعطف کردیم.

## ایجاد kprobeهای اختصاصی

در ابتدا به علت نبود Event و یا Trace Point بر روی Kernel Module OVS، اقدام به تعریف کردن Kprobe بر روی Function های مرتبط با OVS که در قسمت بالا مطرح کردیم. لیست مورد نظر به شرح زیر می باشد:

![](RackMultipart20240109-1-uw5vs1_html_97af7073c624a2fb.png)

تصویر 12: لیست Kprobes های تعریف شده

## دستور Perf برای سناریو Ping:

سپس در ضمن اجرای دستور ping، اقدام به اجرای دستور perf stat بر روی Kprobe های تعریف شده در قسمت قبل نمودیم که نتیجه این دستور به شرح زیر می‌باشد:

![](RackMultipart20240109-1-uw5vs1_html_719fdbd0b11fcdea.png)

تصویر 13: مشاهده اطلاعات آماری Event های صدا زده شده در دستور perf

پس از بررسی و آنالیز صورت گرفته Event های زیر را بدست آوردیم:

- vs\_vport\_send
- vs\_vport\_receive
- vs\_dp\_process\_packet
- vs\_flow\_cmd\_dump

در ادامه گزارش به بررسی هر یک از رویدادها می پردازیم.

## رویداد ovs\_vport\_send:

ابتدا اقدام به تهیه Call Stack با استفاده از دستور perf کردیم که دستور آن در تصویر پایین بدست آمد: ![](RackMultipart20240109-1-uw5vs1_html_8254e7adaad3fa83.png)

تصویر 14: دستور perf stat

در ادامه تصویری از نتایج بدست آمده نشان داده میشود.

![](RackMultipart20240109-1-uw5vs1_html_4714f4a27dc845d.png)

تصویر 15: نمایی از perf call graph

سپس برای اطلاع دقیق‌تر از روند ovs-vport-send، از دستور ftrace استفاده کردیم. برای اینکار در ضمن برقراری ارتباط بین Namespace ها دستور ftrace را نیز اجرا کردیم. نتایج در تصویر زیر نمایش داده می‌شود:

![](RackMultipart20240109-1-uw5vs1_html_62de287bc01b983c.png)

تصویر 16: نتیجه دستور ftrace برای تابع ovs\_vport\_send

که در این قسمت به تفضیل توابع مهمی که داخل این تابع صدا زده می‌شود، پرداخته می شود:

در ادامه به بررسی نقطه ای که در فضای Runtime، لینوکس پس دریافت بسته، اجرای روند را به OVS می دهد. برای این منظور به سورس کد لینوکس رفته و با جستجوی تابع \_\_netif\_receive\_skb\_core و آنالیز بدنه تابع مربوطه به متغیر rx\_handler رسیدیم که در این جا با استفاده از Switch case مربوطه، بسته را به OVS ارسال می کند. تصویر مربوط به این متغیر رادر ذیل قرار دادیم:

![](RackMultipart20240109-1-uw5vs1_html_4d76a1a922519de2.png)

تصویر 17:نقطه اتصال کرنل لینوکس به OVS\_MODULE
</div>
